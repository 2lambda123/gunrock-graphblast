For those that are constructing C and C++ GraphBLAS signature mockups, I propose that we mockup our first full example along the lines of constructing sparse matrices A, B, C.  Multiplying A and B and assigning to C.  Getting the triples out of C.  The matlab equivalent might be:

A = sparse([1 2 3],[1 2 3],[1 1 1],3,3);
B = sparse([1 2 3],[1 2 3],[1 1 1],3,3);

C = A * B;

[i j v] = find(C);


Aydin's signatures:

C++:
template <typename BinaryOp, typename Scalar)
MxM(Matrix & A, Matrix & B, Matrix & C, BinaryOp mult, BinaryOp add, OutType SAID, flags = 0000)  // default value of flags is 0000

#define transA 0001
#define transB 0010
#define maskA 0100
#define maskB 1000

template <typename DS> // DS is the concrete sparse matrix data structure, such as CSC
class SparseMatrix<DS> : public Matrix

usage:
SparseMatrix<CSC> A, B, C; // CSC should also be templated w.r.t. scalar type
MxM(A, B, C, std::plus<float>, std::min<float>, std::numeric_limits<float>::infinity(), transA | transB | maskB)
MxM(A, B, C, [](bool a, int b) -> int {return b;}, std::min<int>, 0, transA)   // BFS iteration
MxM(A, B, C)

Note: For C++, Iâ€™d prefer a semiring object that encapsulates (mult, add, SAID) into a single class


C:
requires enumeration of matrix sparsity and its data structure in the function name, so just including the one with the doubles.

SpCSC_MxM_double(SpCSCMat * A, SpCSCMat * B, SpCSCMat * C,
double (*multptr) (double, double), double (*addptr) (double, double), double SAID, flags = 0000)

Note: my syntax with function pointers might be off
